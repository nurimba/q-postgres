module.exports=function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=1)}([function(e,t){e.exports=require("pg")},function(e,t,n){"use strict";n.r(t);var r=n(0),i=n.n(r);const o="NUMERIC(15,2)",a="INTEGER",s="NUMERIC(15,8)",l="REFERENCES",d=[a,"SMALLINT","SERIAL PRIMARY KEY"],u=e=>"object"==typeof e?"JSONB"===e.type:"JSONB"===e;var c={TEXT:"TEXT",DATE:"DATE",NAME:"VARCHAR(255)",JSON:"JSON",ARRAY:"JSONB",CHAR1:"CHAR(1)",CHAR2:"CHAR(2)",CHAR8:"CHAR(8)",EMAIL:"VARCHAR(50)",PHONE:"VARCHAR(30)",MONEY:o,STRING:"VARCHAR(255)",SELECT:"VARCHAR(25)",CITEXT:"CITEXT",BOOLEAN:"BOOLEAN",INTEGER:a,CPFCNPJ:"VARCHAR(14)",PERCENT:s,PRIMARY:"SERIAL PRIMARY KEY",DATETIME:"TIMESTAMP",SMALLINT:"SMALLINT",NOT_NULL:"NOT NULL",REFERENCES:l};const b=e=>Object.keys(e).map(t=>{return"acao"===t.toLowerCase()||u(e[t])?`${t}::JSONB`:(e=>"object"==typeof e?d.indexOf(e.type)>-1:d.indexOf(e)>-1)(e[t])?`${t}::INT`:(e=>"object"==typeof e?o===e.type:o===e)(e[t])?`${t}::NUMERIC(15,2)`:(e=>"object"==typeof e?s===e.type:s===e)(e[t])?`${t}::NUMERIC(15,8)`:(e=>"object"==typeof e?"BOOLEAN"===e.type:"BOOLEAN"===e)(e[t])?`${t}::BOOLEAN`:t}).join(",");const p={eq:"=",lt:"<",gt:">",lq:"<=",gq:">=",df:"<>",lk:"like","==":"=","<<":"<",">>":">","<=":"<=",">=":">=","<>":"<>","%%":"like"};var f=e=>{let t=p.eq;if("string"!=typeof e)return{comparator:t,value:e};const n=e.split(":"),r=n.shift();if(!p.hasOwnProperty(r))return{comparator:t,value:e};t=p[r];const i=n.join(":").trim();return{comparator:t,value:"like"===t?`%${i}%`:i}};const v=(e,t)=>Object.keys(e).map(n=>{const r=e[n];if("$or"===n.toLowerCase())return`(${v(r,t).join(") OR (")})`;if("$and"===n.toLowerCase())return`(${v(r,t).join(") AND (")})`;if(Array.isArray(r)){let e=[];return r.forEach(r=>{if("object"==typeof r)return e=e.concat(v(r,t));e.push($(n,r,t))}),`(${e.join(") OR (")})`}return $(n,r,t)}),$=(e,t,n)=>{const{comparator:r,value:i}=f(t);return null===i&&"="===r?`${e} is null`:(n.push(i),`${e} ${r} $${n.length}`)};const E=e=>{const t={schema:e,values:{}};return t.toSQL=(e=>{const{schema:t,listFields:n,paramters:r}=e,{table:i,fields:o}=t,a=b(o);return`\nINSERT INTO ${i} (${n.join(", ")})\nVALUES (${r.join(", ")})\nRETURNING ${a};\n`.trim()}).bind(void 0,t),t.objValues=((e,t)=>{const{schema:n}=e,{fields:r}=n;return e.values=[],e.paramters=[],e.listFields=Object.keys(t).filter(e=>r.hasOwnProperty(e)&&void 0!==t[e]),e.listFields.forEach(n=>{const i="acao"===n.toLowerCase()||u(r[n]),o=t[n];if(i)return e.paramters.push(`'${JSON.stringify([o])}'::JSONB`);e.values.push(o),e.paramters.push(`$${e.values.length}`)}),e}).bind(void 0,t),t},O=e=>{const t={schema:e,values:[],conditions:[]};return t.toSQL=(e=>{const{schema:t,paramters:n,conditions:r}=e,{table:i,fields:o}=t,a=b(o),s=r&&r.length?`\nWHERE (${r.join(")\n  AND (")})`:"";return`\nUPDATE ${i} SET\n  ${n.join(",\n  ")}${s}\nRETURNING ${a};\n`.trim()}).bind(void 0,t),t.objValues=((e,t,n)=>{const{schema:r}=e,{fields:i}=r;return e.values=[],e.paramters=[],Object.keys(t).filter(e=>i.hasOwnProperty(e)&&void 0!==t[e]).forEach(n=>{const r="acao"===n.toLowerCase()||u(i[n]),o=t[n];if(r)return e.paramters.push(`${n} = ${n} || '${JSON.stringify([o])}'::JSONB`);e.values.push(o),e.paramters.push(`${n} = $${e.values.length}`)}),e.conditions=Object.keys({...n}).map((t,r)=>{const{comparator:i,value:o}=f(n[t]);return e.values.push(o),`${t} ${i} $${e.values.length}`}),e}).bind(void 0,t),t},m=e=>{const t={schema:e,values:[],conditions:[]};return t.toSQL=(e=>{const{schema:t,conditions:n}=e,{table:r,fields:i}=t,o=b(i);return`\nDELETE FROM ${r}${n&&n.length?`\nWHERE (${n.join(")\n  AND (")})`:""}\nRETURNING ${o};\n`.trim()}).bind(void 0,t),t.objValues=((e,t)=>(e.values=[],e.conditions=Object.keys(t||{}).map((n,r)=>{const{comparator:i,value:o}=f(t[n]);return e.values.push(o),`${n} ${i} $${r+1}`}),e)).bind(void 0,t),t},h=()=>{const e={tableName:"",fields:[],order:[],group:[],values:[],joins:[]};return e.from=((e,t)=>Object.assign(e,{tableName:t})).bind(void 0,e),e.join=((e,t)=>(e.joins.push(t),e)).bind(void 0,e),e.skip=((e,t)=>Object.assign(e,{skipRows:t})).bind(void 0,e),e.limit=((e,t)=>Object.assign(e,{limitRows:t})).bind(void 0,e),e.field=((e,t)=>(e.fields.push(t),e)).bind(void 0,e),e.toSQL=(({tableName:e,fields:t,order:n,group:r,conditions:i,limitRows:o,skipRows:a,joins:s})=>{const l=a?`\nOFFSET ${a}`:"",d=o?`\nLIMIT ${o}`:"",u=n&&n.length?`\nORDER BY ${n.join(", ")}`:"",c=r&&r.length?`\nGROUP BY ${r.join(", ")}`:"",b=i&&i.length?`\nWHERE (${i.join(")\n  AND (")})`:"",p=s&&s.length?`\n${s.join("\n")}`:"";return`\nSELECT ${t.join(", ")}\nFROM ${e}${p}${b}${c}${u}${d}${l}\n  `.trim()}).bind(void 0,e),e.where=((e,t)=>(t||(t={}),e.conditions||(e.conditions=[]),e.conditions=e.conditions.concat(v(t,e.values)),e)).bind(void 0,e),e.value=((e,t)=>(e.values||(e.values=[]),e.values.push(t),e)).bind(void 0,e),e.orderBy=((e,t,n)=>(n||(n=""),e.order.push(`${t} ${n.toUpperCase()}`.trim()),e)).bind(void 0,e),e.groupBy=((e,t)=>(e.group.push(t),e)).bind(void 0,e),e.setValues=((e,t)=>(t||(t=[]),e.values||(e.values=[]),e.values=t,e)).bind(void 0,e),e};var N={dropTable:e=>{const t={};return t.toSQL=(e=>`\nDROP TABLE ${e};\n`.trim()).bind(void 0,e),t},alterTable:e=>{const t={tableName:e,adds:[],drops:[],alters:[],indexs:[]},n={};return n.toSQL=(({tableName:e,adds:t,alters:n,drops:r,indexs:i})=>`\nALTER TABLE ${e}\n  ${t.concat(n,r,i).join(",\n  ")};\n`.trim()).bind(void 0,t),n.setType=((e,{alters:t},n,r)=>(t.push(`ALTER COLUMN ${n} TYPE ${r===l?a:r}`),e)).bind(void 0,n,t),n.addColumn=((e,{adds:t},n,r,i,o)=>{let s="",d="";return i&&(s=" NOT NULL"),void 0!==o&&(d=["boolean","number",""].indexOf(typeof o)>-1?` DEFAULT ${String(o).toUpperCase()}`:` DEFAULT '${o}'`),t.push(`ADD COLUMN ${n} ${r===l?a:r}${s}${d}`),e}).bind(void 0,n,t),n.addUnique=((e,{tableName:t,indexs:n},r)=>(n.push(`ADD CONSTRAINT unique_${t}_${r} UNIQUE (${r})`),e)).bind(void 0,n,t),n.dropUnique=((e,{tableName:t,indexs:n},r)=>(n.push(`DROP CONSTRAINT unique_${t}_${r}`),e)).bind(void 0,n,t),n.dropColumn=((e,{drops:t},n)=>(t.push(`DROP COLUMN ${n} RESTRICT`),e)).bind(void 0,n,t),n.setDefault=((e,{alters:t},n,r)=>{let i="";return void 0!==r&&(i=["boolean","number",""].indexOf(typeof r)>-1?`${String(r).toUpperCase()}`:`'${r}'`),t.push(`ALTER COLUMN ${n} SET DEFAULT ${i}`),e}).bind(void 0,n,t),n.setNotNull=((e,{alters:t},n)=>(t.push(`ALTER COLUMN ${n} SET NOT NULL`),e)).bind(void 0,n,t),n.dropNotNull=((e,{alters:t},n)=>(t.push(`ALTER COLUMN ${n} DROP NOT NULL`),e)).bind(void 0,n,t),n.dropDefault=((e,{alters:t},n)=>(t.push(`ALTER COLUMN ${n} DROP DEFAULT`),e)).bind(void 0,n,t),n.renameColumn=((e,{alters:t},n,r)=>(t.push(`RENAME COLUMN ${n} TO ${r}`),e)).bind(void 0,n,t),n.addForeign=((e,{tableName:t,indexs:n},r,i,o)=>(n.push(`ADD CONSTRAINT foreign_${t}_${r} FOREIGN KEY (${r}) REFERENCES ${i} (${o||"id"})`),e)).bind(void 0,n,t),n.dropForeign=((e,{tableName:t,indexs:n},r)=>(n.push(`DROP CONSTRAINT foreign_${t}_${r}`),e)).bind(void 0,n,t),n},createTable:e=>{const t={tableName:e,columns:[],uniques:[],foreigns:[]},n={};return n.toSQL=(({tableName:e,columns:t,uniques:n,foreigns:r})=>`\nCREATE TABLE ${e} (\n  ${t.concat(n,r).join(",\n  ")}\n);\n`.trim()).bind(void 0,t),n.unique=((e,{tableName:t,uniques:n},r)=>(n.push(`CONSTRAINT unique_${t}_${r} UNIQUE (${r})`),e)).bind(void 0,n,t),n.column=((e,{columns:t},n,r,i,o)=>{let s="",d="";return i&&(s=" NOT NULL"),void 0!==o&&(d=["boolean","number",""].indexOf(typeof o)>-1?` DEFAULT ${String(o).toUpperCase()}`:` DEFAULT '${o}'`),t.push(`${n} ${r===l?a:r}${s}${d}`),e}).bind(void 0,n,t),n.foreign=((e,{tableName:t,foreigns:n},r,i,o)=>(n.push(`CONSTRAINT foreign_${t}_${r} FOREIGN KEY (${r}) REFERENCES ${i} (${o||"id"})`),e)).bind(void 0,n,t),n},insertTable:E,updateTable:O,deleteTable:m,selectTable:h};var y=(e,t)=>(Object.keys(e.fields).forEach(n=>{const r=String(n||"").toLowerCase(),i=Boolean(n!==r),d=i?r:n;if(!t.hasOwnProperty(d))return;let u=t[d];"DATE"===e.fields[n]&&(u=(e=>{if(!e||!String(e).trim())return null;const t=new Date(e),n=`0${t.getDate()}`.substr(-2),r=`0${t.getMonth()+1}`.substr(-2);return`${t.getFullYear()}-${r}-${n}`})(u)),[o,s].indexOf(e.fields[n])>-1&&(u=(e=>e&&String(e).trim()?parseFloat(e):null)(u)),[a,l].indexOf(e.fields[n])>-1&&(u=(e=>e&&String(e).trim()?parseInt(e,10):null)(u)),t[n]=u,i&&delete t[d]}),t),R=(e,t,...n)=>{n&&n.length||(n=Object.keys(t.fields));let r=h();return r.from(t.table),n.forEach(e=>r.field(e)),r.run=(async()=>{const n=r.values,i=r.toSQL(),o=await e.execute(i,n);return o.rows&&o.rows.length&&(o.rows=o.rows.map(y.bind(void 0,t))),o}),r};const T=(e,t,n,r,i)=>{const{hasMany:o}=n;return Promise.all(Object.keys(o||{}).map(async n=>{const{table:a,field:s}=o[n],l=e[a],d=R.bind(void 0,t,l);let u={[s]:r.id};l.deleteField&&(u[l.deleteField]=!1);const{rows:c}=await d("id").where(u).run();c&&c.length&&(r[n]=await Promise.all(c.map(({id:n})=>S(e,t,l,n,i))))}))},A=(e,t,n,r,i)=>{const{manyToMany:o}=n;return Promise.all(Object.keys(o||{}).map(async n=>{const{table:a,primary:s,secondary:l,extraFields:d,schema:u}=o[n],c=e[a],b=R.bind(void 0,t,c),p=Object.keys(d);let f={[s]:r.id};c.deleteField&&(f[c.deleteField]=!1);const{rows:v}=await b(l,...p).where(f).run();v&&v.length&&(r[n]=await Promise.all(v.map(async n=>{const r=n[l],o=await S(e,t,e[u],r,i);return p.forEach(e=>o[e]=n[e]),o})))}))},S=async(e,t,n,r,i={},o=!0)=>{const a=`${n.table}-${r}`;if(i.hasOwnProperty(a))return{...i[a]};const s=R.bind(void 0,t,n);let l={id:r};n.deleteField&&(l[n.deleteField]=!1);const{rows:d}=await s().where(l).limit(1).run();if(!d||!d.length)return;const u=d.shift();return i[a]=u,o?(await T(e,t,n,u,i),await A(e,t,n,u,i),{...u}):{...u}};var L=(e,t,n)=>{const r={};return Object.keys(n.fields).forEach(i=>{const o=`findBy${i.charAt(0).toUpperCase().concat(i.slice(1))}`;if("id"===i)return r[o]=S.bind(void 0,e,t,n);r[o]=(async(e,t,n,r,i,o={},a=!0)=>{const s=R.bind(void 0,t,n);let l={[r]:i};n.deleteField&&(l[n.deleteField]=!1);let{rows:d}=await s().where(l).run();return d&&d.length?a?Promise.all(d.map(async r=>(await T(e,t,n,r,o),await A(e,t,n,r,o),r))):d:[]}).bind(void 0,e,t,n,i)}),r};const g=async(e,t,n,r,i,o)=>(await(async(e,t,n,{hasMany:r},i,o)=>{const{id:a}=i;await Promise.all(Object.keys(r||{}).map(async s=>{const l=o[s];if(!l||!l.length)return;const{table:d,field:u}=r[s],c=t[d];i[s]=await Promise.all(l.map((r,i)=>{const o={...r,[u]:a},s=o.id;return s?j(e,t,n,c,o,{id:s}):w(e,t,n,c,o)})),c.deleteField&&(i[s]=i[s].filter(e=>!e[c.deleteField]))}))})(e,t,n,r,i,o),await(async(e,t,n,{manyToMany:r},i,o)=>{const{id:a}=i;return Promise.all(Object.keys(r||{}).map(async s=>{const l=o[s];if(!l||!l.length)return;const{table:d,primary:u,secondary:c,schema:b,extraFields:p}=r[s],f=t[b];i[s]=await Promise.all(l.map((r,i)=>{let o={...r};Object.keys(p).forEach(e=>delete o[e]);const a=o.id;return a?j(e,t,n,f,o,{id:a}):w(e,t,n,f,o)})),f.deleteField&&(i[s]=i[s].filter(e=>!e[f.deleteField])),await Promise.all(l.map(async(r,o)=>{const l={};Object.keys(p).forEach(e=>l[e]=r[e]);const b=i[s][o].id;l[u]=a,l[c]=b;const f=R.bind(void 0,n,t[d]),{rows:v}=await f("id").from(d).where({[u]:a,[c]:b}).limit(1).run(),$=v&&v.length?v.shift().id:void 0,E=$?await j(e,t,n,t[d],l,{id:$}):await w(e,t,n,t[d],l);Object.keys(p).forEach(e=>Object.assign(i[s][o],{[e]:E[e]}))}))}))})(e,t,n,r,i,o),i),w=async(e,t,n,r,i)=>{let o;r.hasOwnProperty("beforeSave")&&(o=await r.beforeSave(i,e(r.table),e)),o&&Object.keys(o).length&&(i=o);const a=E(r).objValues(i),s=a.values,l=a.toSQL(),{rows:d}=await n.execute(l,s);if(!d||!d.length)return;let u,c=d.map(y.bind(void 0,r)).shift();r.hasOwnProperty("afterSave")&&(u=await r.afterSave(c,e(r.table),e)),u&&u.id&&(c=u);const b=await g(e,t,n,r,c,i);return r.ignoreFields&&r.ignoreFields.forEach(e=>delete b[e]),b},j=async(e,t,n,r,i,o)=>{let a;r.hasOwnProperty("beforeSave")&&(a=await r.beforeSave(i,e(r.table),e)),a&&Object.keys(a).length&&(i=a);const s=O(r).objValues(i,o),l=s.values,d=s.toSQL(),{rows:u}=await n.execute(d,l);if(!u||!u.length)return;let c,b=u.map(y.bind(void 0,r)).shift();r.hasOwnProperty("afterSave")&&(c=await r.afterSave(b,e(r.table),e)),c&&c.id&&(b=c);const p=await g(e,t,n,r,b,i);return r.ignoreFields&&r.ignoreFields.forEach(e=>delete p[e]),p},C=(e,t,n)=>{const r=JSON.parse(JSON.stringify(e[n]));e[n].hasOwnProperty("afterSave")&&(r.afterSave=e[n].afterSave),e[n].hasOwnProperty("beforeSave")&&(r.beforeSave=e[n].beforeSave);const i=C.bind(void 0,e,t),o={schema:r};return o.select=R.bind(void 0,t,r),o.delete=(async(e,t,n)=>{const r=m(t).objValues(n),i=r.values,o=r.toSQL(),{rows:a}=await e.execute(o,i);if(a&&a.length)return a.map(y.bind(void 0,t)).shift()}).bind(void 0,t,r),o.insert=w.bind(void 0,i,e,t,r),o.update=j.bind(void 0,i,e,t,r),Object.assign(o,L(e,t,r))};var P=e=>{const t={};return e.forEach(e=>Object.assign(t,{[e.table]:e})),((e,t)=>C.bind(void 0,e,t)).bind(void 0,t)};n.d(t,"types",function(){return F}),n.d(t,"genSQL",function(){return I});const F=c,I=N;t.default=(e=>{const t=new i.a.Pool(e);return{connect:(async(e,t)=>e.connect().then(e=>{e.config=t;const n={release:()=>e.release(!0),execute:(t,n=[])=>e.query(t,n),commit:()=>e.query("COMMIT").then(()=>n),rollback:()=>e.query("ROLLBACK").then(()=>n),startTransaction:()=>e.query("BEGIN").then(()=>n)};return n})).bind(void 0,t,e),orm:P,pool:t}})}]);